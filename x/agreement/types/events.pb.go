// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stateset/agreement/v1beta1/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventCreateAgreement is an event emitted when an agreement is created.
type EventCreateAgreement struct {
	// agreement_id is the unique ID of agreement
	AgreementId string `protobuf:"bytes,1,opt,name=agreement_id,json=agreementId,proto3" json:"agreement_id,omitempty" yaml:"agreement_id"`
	// creator is the account address creator of the agreement
	Creator string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
	// counterparty is the account address of the counterparty of the agreement.
	Counterparty string `protobuf:"bytes,3,opt,name=counterparty,proto3" json:"counterparty,omitempty"`
	// total_amount is the total number of credits in the credit batch.
	TotalAmount string `protobuf:"bytes,4,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty" yaml:"total_amount"`
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified.
	StartDate string `protobuf:"bytes,5,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty" yaml:"start_date"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified.
	EndDate string `protobuf:"bytes,6,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty" yaml:"end_date"`
}

func (m *EventCreateAgreement) Reset()         { *m = EventCreateAgreement{} }
func (m *EventCreateAgreement) String() string { return proto.CompactTextString(m) }
func (*EventCreateAgreement) ProtoMessage()    {}
func (*EventCreateAgreement) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a0a37e57a9a513, []int{0}
}
func (m *EventCreateAgreement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCreateAgreement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCreateAgreement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCreateAgreement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCreateAgreement.Merge(m, src)
}
func (m *EventCreateAgreement) XXX_Size() int {
	return m.Size()
}
func (m *EventCreateAgreement) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCreateAgreement.DiscardUnknown(m)
}

var xxx_messageInfo_EventCreateAgreement proto.InternalMessageInfo

func (m *EventCreateAgreement) GetAgreementId() string {
	if m != nil {
		return m.AgreementId
	}
	return ""
}

func (m *EventCreateAgreement) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *EventCreateAgreement) GetCounterparty() string {
	if m != nil {
		return m.Counterparty
	}
	return ""
}

func (m *EventCreateAgreement) GetTotalAmount() string {
	if m != nil {
		return m.TotalAmount
	}
	return ""
}

func (m *EventCreateAgreement) GetStartDate() string {
	if m != nil {
		return m.StartDate
	}
	return ""
}

func (m *EventCreateAgreement) GetEndDate() string {
	if m != nil {
		return m.EndDate
	}
	return ""
}

// EventActivated is an event emitted when an agreement is activated.
type EventActivated struct {
	// agreement_id is the unique ID of agreement
	AgreementId string `protobuf:"bytes,1,opt,name=agreement_id,json=agreementId,proto3" json:"agreement_id,omitempty" yaml:"agreement_id"`
	// activator is the activator of the agreement
	Activator string `protobuf:"bytes,2,opt,name=activator,proto3" json:"activator,omitempty"`
	// activation_date is the beginning of the period during which this agreement
	// was activated.
	ActivationDate string `protobuf:"bytes,3,opt,name=activation_date,json=activationDate,proto3" json:"activation_date,omitempty" yaml:"start_date"`
}

func (m *EventActivated) Reset()         { *m = EventActivated{} }
func (m *EventActivated) String() string { return proto.CompactTextString(m) }
func (*EventActivated) ProtoMessage()    {}
func (*EventActivated) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a0a37e57a9a513, []int{1}
}
func (m *EventActivated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventActivated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventActivated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventActivated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventActivated.Merge(m, src)
}
func (m *EventActivated) XXX_Size() int {
	return m.Size()
}
func (m *EventActivated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventActivated.DiscardUnknown(m)
}

var xxx_messageInfo_EventActivated proto.InternalMessageInfo

func (m *EventActivated) GetAgreementId() string {
	if m != nil {
		return m.AgreementId
	}
	return ""
}

func (m *EventActivated) GetActivator() string {
	if m != nil {
		return m.Activator
	}
	return ""
}

func (m *EventActivated) GetActivationDate() string {
	if m != nil {
		return m.ActivationDate
	}
	return ""
}

// EventRenewed is an event emitted when an agreement is renewed.
type EventRenewed struct {
	// agreement_id is the unique ID of agreement
	AgreementId string `protobuf:"bytes,1,opt,name=agreement_id,json=agreementId,proto3" json:"agreement_id,omitempty" yaml:"agreement_id"`
	// renewer is the renewer of the agreement
	Renewer string `protobuf:"bytes,2,opt,name=renewer,proto3" json:"renewer,omitempty"`
	// renewal_date is the beginning of the period during which this agreement was renewed
	RenewalDate string `protobuf:"bytes,3,opt,name=renewal_date,json=renewalDate,proto3" json:"renewal_date,omitempty" yaml:"start_date"`
}

func (m *EventRenewed) Reset()         { *m = EventRenewed{} }
func (m *EventRenewed) String() string { return proto.CompactTextString(m) }
func (*EventRenewed) ProtoMessage()    {}
func (*EventRenewed) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a0a37e57a9a513, []int{2}
}
func (m *EventRenewed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRenewed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRenewed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRenewed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRenewed.Merge(m, src)
}
func (m *EventRenewed) XXX_Size() int {
	return m.Size()
}
func (m *EventRenewed) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRenewed.DiscardUnknown(m)
}

var xxx_messageInfo_EventRenewed proto.InternalMessageInfo

func (m *EventRenewed) GetAgreementId() string {
	if m != nil {
		return m.AgreementId
	}
	return ""
}

func (m *EventRenewed) GetRenewer() string {
	if m != nil {
		return m.Renewer
	}
	return ""
}

func (m *EventRenewed) GetRenewalDate() string {
	if m != nil {
		return m.RenewalDate
	}
	return ""
}

// EventTerminated is an event emitted when an agreement is terminated.
type EventTerminated struct {
	// agreement_id is the unique ID of agreement
	AgreementId string `protobuf:"bytes,1,opt,name=agreement_id,json=agreementId,proto3" json:"agreement_id,omitempty" yaml:"agreement_id"`
	// terminator is the terminator of the agreement
	Terminator string `protobuf:"bytes,2,opt,name=terminator,proto3" json:"terminator,omitempty"`
	// termination_date is the when this agreement was terminated
	TerminationDate string `protobuf:"bytes,3,opt,name=termination_date,json=terminationDate,proto3" json:"termination_date,omitempty" yaml:"start_date"`
}

func (m *EventTerminated) Reset()         { *m = EventTerminated{} }
func (m *EventTerminated) String() string { return proto.CompactTextString(m) }
func (*EventTerminated) ProtoMessage()    {}
func (*EventTerminated) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a0a37e57a9a513, []int{3}
}
func (m *EventTerminated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTerminated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTerminated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTerminated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTerminated.Merge(m, src)
}
func (m *EventTerminated) XXX_Size() int {
	return m.Size()
}
func (m *EventTerminated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTerminated.DiscardUnknown(m)
}

var xxx_messageInfo_EventTerminated proto.InternalMessageInfo

func (m *EventTerminated) GetAgreementId() string {
	if m != nil {
		return m.AgreementId
	}
	return ""
}

func (m *EventTerminated) GetTerminator() string {
	if m != nil {
		return m.Terminator
	}
	return ""
}

func (m *EventTerminated) GetTerminationDate() string {
	if m != nil {
		return m.TerminationDate
	}
	return ""
}

// EventAmended is an event emitted when an agreement is amended.
type EventAmended struct {
	// agreement_id is the unique ID of agreement
	AgreementId string `protobuf:"bytes,1,opt,name=agreement_id,json=agreementId,proto3" json:"agreement_id,omitempty" yaml:"agreement_id"`
	// amender is the renewer of the amender
	Amender string `protobuf:"bytes,2,opt,name=amender,proto3" json:"amender,omitempty"`
	// amendment_date is the beginning of the period during which this agreement was amended
	AmendmentDate string `protobuf:"bytes,3,opt,name=amendment_date,json=amendmentDate,proto3" json:"amendment_date,omitempty" yaml:"start_date"`
}

func (m *EventAmended) Reset()         { *m = EventAmended{} }
func (m *EventAmended) String() string { return proto.CompactTextString(m) }
func (*EventAmended) ProtoMessage()    {}
func (*EventAmended) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a0a37e57a9a513, []int{4}
}
func (m *EventAmended) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAmended) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAmended.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAmended) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAmended.Merge(m, src)
}
func (m *EventAmended) XXX_Size() int {
	return m.Size()
}
func (m *EventAmended) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAmended.DiscardUnknown(m)
}

var xxx_messageInfo_EventAmended proto.InternalMessageInfo

func (m *EventAmended) GetAgreementId() string {
	if m != nil {
		return m.AgreementId
	}
	return ""
}

func (m *EventAmended) GetAmender() string {
	if m != nil {
		return m.Amender
	}
	return ""
}

func (m *EventAmended) GetAmendmentDate() string {
	if m != nil {
		return m.AmendmentDate
	}
	return ""
}

// EventExpired is an event emitted when an agreement is expired.
type EventExpired struct {
	// agreement_id is the unique ID of agreement
	AgreementId string `protobuf:"bytes,1,opt,name=agreement_id,json=agreementId,proto3" json:"agreement_id,omitempty" yaml:"agreement_id"`
	// expirer is the renewer of the expirer
	Expirer string `protobuf:"bytes,2,opt,name=expirer,proto3" json:"expirer,omitempty"`
	// expirer_date is the beginning of the period during which this agreement was expired
	ExpirationDate string `protobuf:"bytes,3,opt,name=expiration_date,json=expirationDate,proto3" json:"expiration_date,omitempty" yaml:"start_date"`
}

func (m *EventExpired) Reset()         { *m = EventExpired{} }
func (m *EventExpired) String() string { return proto.CompactTextString(m) }
func (*EventExpired) ProtoMessage()    {}
func (*EventExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a0a37e57a9a513, []int{5}
}
func (m *EventExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventExpired.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventExpired.Merge(m, src)
}
func (m *EventExpired) XXX_Size() int {
	return m.Size()
}
func (m *EventExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_EventExpired.DiscardUnknown(m)
}

var xxx_messageInfo_EventExpired proto.InternalMessageInfo

func (m *EventExpired) GetAgreementId() string {
	if m != nil {
		return m.AgreementId
	}
	return ""
}

func (m *EventExpired) GetExpirer() string {
	if m != nil {
		return m.Expirer
	}
	return ""
}

func (m *EventExpired) GetExpirationDate() string {
	if m != nil {
		return m.ExpirationDate
	}
	return ""
}

func init() {
	proto.RegisterType((*EventCreateAgreement)(nil), "stateset.agreement.v1beta1.EventCreateAgreement")
	proto.RegisterType((*EventActivated)(nil), "stateset.agreement.v1beta1.EventActivated")
	proto.RegisterType((*EventRenewed)(nil), "stateset.agreement.v1beta1.EventRenewed")
	proto.RegisterType((*EventTerminated)(nil), "stateset.agreement.v1beta1.EventTerminated")
	proto.RegisterType((*EventAmended)(nil), "stateset.agreement.v1beta1.EventAmended")
	proto.RegisterType((*EventExpired)(nil), "stateset.agreement.v1beta1.EventExpired")
}

func init() {
	proto.RegisterFile("stateset/agreement/v1beta1/events.proto", fileDescriptor_27a0a37e57a9a513)
}

var fileDescriptor_27a0a37e57a9a513 = []byte{
	// 507 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xb1, 0x8e, 0xd3, 0x40,
	0x14, 0x8c, 0xef, 0xe0, 0x42, 0x36, 0x21, 0x81, 0xbd, 0x43, 0x58, 0x27, 0xe4, 0x20, 0x37, 0xd0,
	0x60, 0xeb, 0x04, 0x05, 0x9c, 0x10, 0x22, 0x07, 0x57, 0xd0, 0x1a, 0x2a, 0x9a, 0x68, 0x63, 0x3f,
	0xe5, 0x2c, 0xe2, 0xdd, 0x68, 0xfd, 0x2e, 0x5c, 0xfe, 0x82, 0x2f, 0xa0, 0x40, 0x54, 0x34, 0x48,
	0x7c, 0x05, 0xe5, 0x95, 0x54, 0x11, 0x4a, 0xfe, 0x20, 0x5f, 0x80, 0xfc, 0x6c, 0x6f, 0x0c, 0x05,
	0x17, 0xc9, 0xdd, 0x9b, 0x7d, 0x33, 0xe3, 0xc9, 0x64, 0xb5, 0xec, 0x41, 0x8a, 0x02, 0x21, 0x05,
	0xf4, 0xc5, 0x58, 0x03, 0x24, 0x20, 0xd1, 0x9f, 0x1d, 0x8d, 0x00, 0xc5, 0x91, 0x0f, 0x33, 0x90,
	0x98, 0x7a, 0x53, 0xad, 0x50, 0xf1, 0xc3, 0x92, 0xe8, 0x19, 0xa2, 0x57, 0x10, 0x0f, 0x0f, 0xc6,
	0x6a, 0xac, 0x88, 0xe6, 0x67, 0x53, 0xae, 0x70, 0x7f, 0xec, 0xb0, 0x83, 0xd3, 0xcc, 0xe2, 0x95,
	0x06, 0x81, 0x30, 0x28, 0x65, 0xfc, 0x98, 0x75, 0x8c, 0xc7, 0x30, 0x8e, 0x6c, 0xeb, 0xbe, 0xf5,
	0xb0, 0x75, 0x72, 0x77, 0xbd, 0xe8, 0xef, 0xcf, 0x45, 0x32, 0x39, 0x76, 0xab, 0x5b, 0x37, 0x68,
	0x1b, 0xf8, 0x26, 0xe2, 0x36, 0x6b, 0x86, 0x99, 0x9d, 0xd2, 0xf6, 0x4e, 0x26, 0x0b, 0x4a, 0xc8,
	0x5d, 0xd6, 0x09, 0xd5, 0xb9, 0x44, 0xd0, 0x53, 0xa1, 0x71, 0x6e, 0xef, 0xd2, 0xfa, 0xaf, 0xb3,
	0xec, 0xcb, 0xa8, 0x50, 0x4c, 0x86, 0x22, 0xc9, 0x8e, 0xed, 0x6b, 0xff, 0x7e, 0xb9, 0xba, 0x75,
	0x83, 0x36, 0xc1, 0x01, 0x21, 0xfe, 0x84, 0xb1, 0x14, 0x85, 0xc6, 0x61, 0x24, 0x10, 0xec, 0xeb,
	0xa4, 0xbc, 0xb3, 0x5e, 0xf4, 0x6f, 0xe7, 0xca, 0xcd, 0xce, 0x0d, 0x5a, 0x04, 0x5e, 0x0b, 0x04,
	0xee, 0xb1, 0x1b, 0x20, 0xa3, 0x5c, 0xb3, 0x47, 0x9a, 0xfd, 0xf5, 0xa2, 0xdf, 0xcb, 0x35, 0xe5,
	0xc6, 0x0d, 0x9a, 0x20, 0xa3, 0x8c, 0xef, 0x7e, 0xb3, 0x58, 0x97, 0x4a, 0x1b, 0x84, 0x18, 0xcf,
	0x04, 0x42, 0x54, 0xab, 0xae, 0x7b, 0xac, 0x25, 0x72, 0x23, 0x53, 0xd8, 0xe6, 0x80, 0xbf, 0x60,
	0xbd, 0x02, 0xc4, 0x4a, 0xe6, 0x19, 0x77, 0xff, 0xf7, 0xbb, 0xba, 0x1b, 0x36, 0x85, 0xfd, 0x6c,
	0xb1, 0x0e, 0x85, 0x0d, 0x40, 0xc2, 0xc7, 0x9a, 0x51, 0x6d, 0xd6, 0xd4, 0x64, 0x63, 0xfe, 0xd9,
	0x02, 0xf2, 0xa7, 0xac, 0x43, 0xa3, 0x98, 0x6c, 0x91, 0xb1, 0x5d, 0x50, 0x29, 0xe0, 0x77, 0x8b,
	0xf5, 0x28, 0xe0, 0x3b, 0xd0, 0x49, 0x2c, 0x6b, 0xd7, 0xe9, 0x30, 0x86, 0x85, 0x93, 0xe9, 0xb3,
	0x72, 0xc2, 0x5f, 0xb2, 0x5b, 0x25, 0xda, 0xae, 0xd1, 0x5e, 0x85, 0x4e, 0x89, 0xbf, 0x94, 0x95,
	0x0e, 0x12, 0x90, 0x51, 0xfd, 0x4a, 0x05, 0xd9, 0x98, 0x4a, 0x0b, 0xc8, 0x9f, 0xb3, 0x2e, 0x8d,
	0xa4, 0xbb, 0x3a, 0xe6, 0x4d, 0x43, 0xa6, 0x90, 0x5f, 0xcb, 0x90, 0xa7, 0x17, 0xd3, 0x58, 0xd7,
	0x0f, 0x09, 0x64, 0x63, 0x42, 0x16, 0x30, 0xbb, 0x9e, 0x34, 0x6e, 0x7d, 0x3d, 0x37, 0xec, 0x2c,
	0xe6, 0xc9, 0xdb, 0x9f, 0x4b, 0xc7, 0xba, 0x5c, 0x3a, 0xd6, 0xef, 0xa5, 0x63, 0x7d, 0x5a, 0x39,
	0x8d, 0xcb, 0x95, 0xd3, 0xf8, 0xb5, 0x72, 0x1a, 0xef, 0x9f, 0x8d, 0x63, 0x3c, 0x3b, 0x1f, 0x79,
	0xa1, 0x4a, 0x7c, 0xf3, 0x00, 0x96, 0xc3, 0xa3, 0xd1, 0x44, 0x85, 0x1f, 0xc2, 0x33, 0x11, 0x4b,
	0xff, 0xa2, 0xf2, 0x2c, 0xe2, 0x7c, 0x0a, 0xe9, 0x68, 0x8f, 0x1e, 0xb7, 0xc7, 0x7f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xf2, 0x71, 0x72, 0x99, 0x39, 0x05, 0x00, 0x00,
}

func (m *EventCreateAgreement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCreateAgreement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCreateAgreement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndDate) > 0 {
		i -= len(m.EndDate)
		copy(dAtA[i:], m.EndDate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.EndDate)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StartDate) > 0 {
		i -= len(m.StartDate)
		copy(dAtA[i:], m.StartDate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.StartDate)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TotalAmount) > 0 {
		i -= len(m.TotalAmount)
		copy(dAtA[i:], m.TotalAmount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TotalAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Counterparty) > 0 {
		i -= len(m.Counterparty)
		copy(dAtA[i:], m.Counterparty)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Counterparty)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgreementId) > 0 {
		i -= len(m.AgreementId)
		copy(dAtA[i:], m.AgreementId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AgreementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventActivated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventActivated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventActivated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActivationDate) > 0 {
		i -= len(m.ActivationDate)
		copy(dAtA[i:], m.ActivationDate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ActivationDate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Activator) > 0 {
		i -= len(m.Activator)
		copy(dAtA[i:], m.Activator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Activator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgreementId) > 0 {
		i -= len(m.AgreementId)
		copy(dAtA[i:], m.AgreementId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AgreementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRenewed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRenewed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRenewed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RenewalDate) > 0 {
		i -= len(m.RenewalDate)
		copy(dAtA[i:], m.RenewalDate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RenewalDate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Renewer) > 0 {
		i -= len(m.Renewer)
		copy(dAtA[i:], m.Renewer)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Renewer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgreementId) > 0 {
		i -= len(m.AgreementId)
		copy(dAtA[i:], m.AgreementId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AgreementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTerminated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTerminated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTerminated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TerminationDate) > 0 {
		i -= len(m.TerminationDate)
		copy(dAtA[i:], m.TerminationDate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TerminationDate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Terminator) > 0 {
		i -= len(m.Terminator)
		copy(dAtA[i:], m.Terminator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Terminator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgreementId) > 0 {
		i -= len(m.AgreementId)
		copy(dAtA[i:], m.AgreementId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AgreementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAmended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAmended) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAmended) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmendmentDate) > 0 {
		i -= len(m.AmendmentDate)
		copy(dAtA[i:], m.AmendmentDate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AmendmentDate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amender) > 0 {
		i -= len(m.Amender)
		copy(dAtA[i:], m.Amender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgreementId) > 0 {
		i -= len(m.AgreementId)
		copy(dAtA[i:], m.AgreementId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AgreementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExpirationDate) > 0 {
		i -= len(m.ExpirationDate)
		copy(dAtA[i:], m.ExpirationDate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExpirationDate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Expirer) > 0 {
		i -= len(m.Expirer)
		copy(dAtA[i:], m.Expirer)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Expirer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgreementId) > 0 {
		i -= len(m.AgreementId)
		copy(dAtA[i:], m.AgreementId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AgreementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventCreateAgreement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgreementId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Counterparty)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TotalAmount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.StartDate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.EndDate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventActivated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgreementId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Activator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ActivationDate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventRenewed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgreementId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Renewer)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.RenewalDate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventTerminated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgreementId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Terminator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TerminationDate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventAmended) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgreementId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Amender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AmendmentDate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgreementId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Expirer)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExpirationDate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventCreateAgreement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCreateAgreement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCreateAgreement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgreementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counterparty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Counterparty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventActivated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventActivated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventActivated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgreementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Activator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRenewed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRenewed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRenewed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgreementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Renewer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Renewer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewalDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenewalDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTerminated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTerminated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTerminated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgreementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terminator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminationDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminationDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAmended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAmended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAmended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgreementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmendmentDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmendmentDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgreementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expirer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expirer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
